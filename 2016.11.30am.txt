--创建和emp结构一样的表 test 没有数据
create table test as select * from emp where 1=2;
select * from test;
--将emp表中 ，工资最高的人的信息插入到test中
insert into test select * from emp where sal=(select max(sal) from emp);

--使用for  loop ,插入三条信息  
--  empno 要求 在empno最大值的基础上，每次递增一
--插入的ename 分别为   zhang1  zhang2  zhang3
select 'zhang'||(1+2) from emp

DECLARE
v_empno emp.empno%type;
v_ename emp.ename%type:='zhang';
begin
 select max(empno) into v_empno from test;  
 --for 后面的  是变量名    in 后面  表示 循环从几开始   中间使用 .. 间隔
 --  .. 后面 是最大循环的次数
 for i in 1..3 loop
   -- 可以使用 ()  将某些部分 执行顺序提前
   insert into test(empno,ename)
   values(v_empno+i,v_ename||i);
 end loop;
 --在循环之外  进行事务提交  ，这个时候无论做多少次操作，只提交一次
 commit;
end;

create table message (
results varchar2(10)
)
select * from message
--方法1
begin
  for i in 1..10 loop
    if i=6 or i=8 then null;
    else 
      insert into message values(i);
    end if;
  end loop;
  commit;
end;
--方法2
begin
  for i in 1..10 loop
    if i<>6 and i<>8 then 
      insert into message values(i);
    end if;
  end loop;
end;

select * from test
--使用while 循环 继续插入3条信息
declare
v_count number(2):=1;
v_empno emp.empno%type;
begin 
  select max(empno) into v_empno from test;
  while v_count<=3 loop
    insert into test (empno,ename)
    values(v_empno+v_count,'&in_ename');
    v_count:=v_count+1;
  end loop; 
  commit;
end;

--goto  的使用
--不能goto 到嵌套块内部的标签
--if 子句外部执行的语句，也不能goto到if子句内部的标签
--if子句内部执行的语句，不能goto到另一个if子句内部的标签
--不能从异常处理部分goto 到其他代码部分
begin
 dbms_output.put_line(1);
 goto abc;
 dbms_output.put_line(2);
 return;
 <<abc>>
 dbms_output.put_line(3); 
end;



--程序分析
declare
i number:=10;
begin
  <<outer_loop>>
  for i in 1..3 loop
    dbms_output.put_line('ok1');
    <<inner_loop>>
    for i in 1..3 loop 
      --可以使用 标签  来区分这里i  有关的内容
      dbms_output.put_line('outer'||outer_loop.i||'inner'
      ||inner_loop.i);
      --在内部循环，可以通过标签操作外部循环
      --如果 内外部循环的i 的和相加超过3 ，那么就直接退出外部循环
      exit outer_loop when (outer_loop.i+inner_loop.i>3);
      --程序都是自上而下执行，如果上面已经退出，那么下面这句话不显示
      dbms_output.put_line('inner'||inner_loop.i);
      --如果continue中判断条件是满足的，为真，就不会输出continue以下的
      --内容
      --只有不满足，  或者  when 当中条件为假的时候，输出continue以下
      --内容
      continue inner_loop when inner_loop.i=2;
      dbms_output.put_line('ok2');
    end loop inner_loop;
  end loop outer_loop;
  --这里的i  和  outer_loop.i  inner_loop.i 没有任何关系
  --只是 声明中的i 
  dbms_output.put_line(i);
end;



--复合数据类型
--  记录 name_record
--  表   name_table
--  嵌套表
--  数组

--创建一个记录
declare
--声明一个记录类型
--emp_record_type  记录类型的 命名
 type emp_record_type is record
 (ename emp.ename%type,
  sal emp.sal%type,
  job varchar2(9)
 );
--给一个记录命名   类型呢，是我们才定义的 emp_record_type
emp_record emp_record_type;
begin 
  --对记录进行操作
  --在不使用游标的情况下，记录呢，也只能插入一条
  select ename,sal,job into emp_record from emp
  where empno = 7369;
  --如何获取记录中的信息   使用  记录名.列名  的方式获取相关信息
  dbms_output.put_line('雇员名:'||emp_record.ename||',薪水是'
  ||emp_record.sal);
end;
 


--   %rowtype 属性
--  声明的变量对应于数据库表或视图中列的集合
--在%ROWTYPE 之前加上数据库表名
--记录内字段的名字和数据类型参照表或视图中的列
declare
--需要一个记录   类型和  emp 表相同
--  emp%rowtype  是一个和emp 表结构相同的  记录类型
emp_rec  emp%rowtype;
begin
  --根据输入的员工编号，将emp表中的一条信息放入 emp_rec 这个记录中
 select * into emp_rec from emp where empno=&in_empno;
 --将记录里面的信息，根据需要 插入到test表  
 --将7782 这个人的  员工编号，工资，入职日期，姓名  插入到test
 insert into test (empno,sal,hiredate,ename)values(emp_rec.empno,
 emp_rec.sal,emp_rec.hiredate,emp_rec.ename);
 commit;
end;
--%ROWTYPE的优点:
--可以不必知道数据库中列的数量和类型。
--在运行期间，数据库中列的数量和类型可能发生变化。
--在SELECT语句中使用该属性可以有效地检索表中的行。

select * from test
select * from emp 
 
--PL/SQL  表
--定义一个table 类型
--声明  一个该类型的变量
DECLARE
 --定义一个表的类型
  --   is table  of  后面，跟的是数据类型
 type ename_table_type is table of emp.ename%type
       index by binary_integer;
 type hiredate_table_type is table of date
       index by binary_integer;
 --声明两个  pl/sql 表
 ename_table ename_table_type;
 hiredate_table hiredate_table_type;
begin
  --向PL/SQL表中添加一定的信息
  ename_table(1):='ALLEN';
  --向hiredate_table 放入另外的信息
  hiredate_table(8):=sysdate+7;
  --判断一下 ，PL/SQL表中是否有内容
  if ename_table.exists(2) then
    dbms_output.put_line(ename_table(1));
  else
    dbms_output.put_line('error');
  end if;
end;
----------------------------------------------------
 DECLARE
 --定义一个表的类型
  --   is table  of  后面，跟的是数据类型
 type ename_table_type is table of emp.ename%type
       index by binary_integer;
 ename_table ename_table_type;      
 begin
   select ename into  ename_table(1) from emp where 
   empno=7369;     
   dbms_output.put_line(ename_table(1));
 end;
 
 select * from test
------------------------------------------------- 
 --在不使用游标的情况下，将test表中的信息，插入到PL/SQL表  ename_table中
 --并将插入的信息呢，打印
 DECLARE
 --定义一个表的类型
  --   is table  of  后面，跟的是数据类型
 type ename_table_type is table of emp.ename%type
       index by binary_integer;
 ename_table ename_table_type;  
 v_empno test.empno%type;    
 begin
   select empno into v_empno from test where ename='KING';
   for i in 1..3 loop
     --PL/SQL 中如果查询不到数据，会报错
     select ename into ename_table(i) from test
     where empno=(v_empno+i-1);
     dbms_output.put_line(i||'位置的数据是'||ename_table(i));
   end loop;
 end;

select * from test where empno=1000;

select * from dept;
--
declare
 type dept_table_type is table of dept%rowtype
 index by binary_integer;
 dept_table dept_table_type;
begin
  --在第一个位置的  deptno 这一列 设置10  这个内容，而dname 为空
  dept_table(1).deptno :=10;
  --在第二个位置的  deptno 这一列 设置为空  这个内容，而dname 为SALES
  dept_table(2).dname :='SALES'; 
  dbms_output.put_line(dept_table(1).deptno);
  dbms_output.put_line('这个值是'||dept_table(1).dname);
  dbms_output.put_line('这个值是'||dept_table(2).dname);
  dbms_output.put_line('这个值是'||dept_table(2).deptno);

end;